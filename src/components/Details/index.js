import React, { Component, Fragment } from  'react'
import { View, TouchableOpacity, Platform, Linking, PushNotificationIOS} from 'react-native'
import { Thumbnail, Spinner } from 'native-base'
import { 
	Container, TypeTitle, TypeDescription, TypeImage, RequestButton, RequestButtonText, RestaurantButton
 } from './style'
import * as firebase from 'firebase'
import { connect } from 'react-redux'
import { setRide } from '../../redux/action/ride'
import { setUser } from '../../redux/action/auth'

import _ from 'lodash'
import moment from 'moment'

import Sound from 'react-native-sound'
import PushNotification from 'react-native-push-notification'

const today = moment().format('DD/MM/YYYY')

PushNotification.configure({

	// (required) Called when a remote or local notification is opened or received
	onNotification: function(notification) {
			console.log( 'NOTIFICATION:', notification );
			// process the notification
			// required on iOS only (see fetchCompletionHandler docs: https://facebook.github.io/react-native/docs/pushnotificationios.html)
			notification.finish(PushNotificationIOS.FetchResult.NoData);
	},

	// Should the initial notification be popped automatically
	// default: true
	popInitialNotification: true,

	/**
		* (optional) default: true
		* - Specified if permissions (ios) and token (android and ios) will requested or not,
		* - if not, you must call PushNotificationsHandler.requestPermissions() later
		*/
	requestPermissions: true,
});

var alert = new Sound('alert.mp3', Sound.MAIN_BUNDLE, (error) => {
  if (error) {
    console.log('failed to load the sound', error);
	}
})

class Details extends Component {
	state = {
		loading: false,
		timeout: null
	}


	componentDidMount(){
		console.log('testando time', !this.props.user.onRide && this.props.isRide)
		if(!this.props.user.onRide && this.props.isRide){

		const timeout = setTimeout(() => this.refuseRide(), 10*1200);
			this.setState({ timeout })
			alert.play((success) => {
				if (success) {
					console.log('successfully finished playing');
				} else {
					console.log('playback failed due to audio decoding errors');
				}
			});
			PushNotification.localNotification({
				/* Android Only Properties */
				id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
				ticker: "Uma nova Entrega para você", // (optional)
				autoCancel: true, // (optional) default: true
				largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
				smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
				bigText: "Olá uma nova Entrega surgiu. Você tem 10s para aceitar", // (optional) default: "message" prop
				subText: "Entrega para você", // (optional) default: none
				color: "red", // (optional) default: system default
				vibrate: true, // (optional) default: true
				vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
				tag: 'some_tag', // (optional) add tag to message
				group: "group", // (optional) add group to message
				ongoing: false, // (optional) set whether this is an "ongoing" notification
				priority: "high", // (optional) set notification priority, default: high
				visibility: "private", // (optional) set notification visibility, default: private
				importance: "high", // (optional) set notification importance, default: high
		
				/* iOS and Android properties */
				title: "Uma nova entrega para você", // (optional)
				message: "Olá uma nova Entrega surgiu. Você tem 10s para aceitar", // (required)
				playSound: true, // (optional) default: true
		});
			return timeout
		}
		// } else { 
		// 	return clearTimeout(timeOut)
		// }
	}

	handleAcceptRide = async () => {
		clearTimeout(this.state.timeout)
		this.setState({ loading: true })
		await firebase.database().ref(`register/commerce/motoboyPartner/${this.props.user.id}`).update({
			onRide: true,
			activeRide: this.props.ride,
		})
			.then(async () => {
				await firebase.database().ref(`rides/${this.props.ride.id}`).update({
					status: 'onWay'
				})
					.then(() => {
						this.props.setRide({
							...this.props.ride,
							status: 'onWay'
						})
						this.props.setUser({
							...this.props.user,
							onRide: true,
							activeRide: this.props.ride,
							earnings: this.props.user.earnings ? [ ...Object.values(this.props.user.earnings) ,{ date: this.props.ride.createdAt, tax: this.props.ride.tax }] : [{ date: this.props.ride.createdAt, tax: this.props.ride.tax }],
							rides: this.props.user.rides ? [...Object.values(this.props.user.rides), this.props.ride] : [this.props.ride]
						})
						this.setState({ loading: false })
					})
					.catch(error => {
						this.setState({ loading: false })
						console.log('error updating ride status', error)
					})
			})
			.catch(error => {
				console.log('error updating motoboy', error)
				Alert.alert('Atenção', 'Houve uma falha, favor tente novamente em instantes')
				this.setState({ loading: false })
			})
	}

	handleRide = (ride) => {
		console.log(ride.status)
		let restaurantLat = ride.restaurant.latitude
		let restaurantLong = ride.restaurant.longitude
		let deliveryLat = ride.delivery.latitude
		let deliveryLong = ride.delivery.longitude 

			if(ride.status === 'pending'){
				return (
					<Fragment>
						<TypeTitle>Você tem uma entrega disponível</TypeTitle>
						<TypeDescription>Clique abaixo para aceitar</TypeDescription>
						{this.state.loading ? <Spinner /> : (
							<Fragment>
								<TouchableOpacity onPress={this.handleAcceptRide}>
									<Thumbnail large source={require('../../assets/motoboy.png')} />
								</TouchableOpacity>
								<TypeTitle>{this.props.ride.name}</TypeTitle>
								<TypeDescription>{this.props.rideDistance/1000} km</TypeDescription>
				
								<RequestButton onPress={this.refuseRide}>
									<RequestButtonText>Recusar</RequestButtonText>
								</RequestButton>
							</Fragment>
						)}
					</Fragment>
				)
			} else if( ride.status === 'onWay'){
				return (
					<Fragment>
						<TypeTitle>Escolha um mapa abaixo para iniciar a navegação</TypeTitle>
						<TypeDescription>Clique no mapa para abrir</TypeDescription>
							<Fragment>
								<View style={{ flexDirection: 'row', justifyContent: 'space-around'}}>
									<TouchableOpacity onPress={() => this.openGoogleMaps(restaurantLat, restaurantLong)}>
										<Thumbnail large source={require('../../assets/google.png')} />
									</TouchableOpacity>
								</View>
								<RestaurantButton onPress={this.onRestaurant}>
									<RequestButtonText>Cheguei no restaurante</RequestButtonText>
								</RestaurantButton>
							</Fragment>
					</Fragment>
				)		
			} else if( ride.status === 'onRestaurant') {
				return (
					<Fragment>
						<TypeTitle>Escolha um mapa abaixo para iniciar a navegação</TypeTitle>
						<TypeDescription>Clique no mapa para abrir</TypeDescription>
							<Fragment>
								<View style={{ flexDirection: 'row', justifyContent: 'space-around'}}>
									<TouchableOpacity onPress={() => this.openGoogleMaps(deliveryLat, deliveryLong)}>
										<Thumbnail large source={require('../../assets/google.png')} />
									</TouchableOpacity>
								</View>
								<RestaurantButton onPress={this.startDelivery}>
									<RequestButtonText>Iniciar entrega</RequestButtonText>
								</RestaurantButton>
							</Fragment>
					</Fragment>
				)		
			} else if( ride.status === 'onDelivery') {
				return (
					<Fragment>
						<TypeTitle>Escolha um mapa abaixo para iniciar a navegação</TypeTitle>
						<TypeDescription>Clique no mapa para abrir</TypeDescription>
							<Fragment>
								<View style={{ flexDirection: 'row', justifyContent: 'space-around'}}>
									<TouchableOpacity onPress={() => this.openGoogleMaps(restaurantLat, restaurantLong)}>
										<Thumbnail large source={require('../../assets/google.png')} />
									</TouchableOpacity>
								</View>
								<RestaurantButton onPress={ride.retorno ? this.wayBack : this.finishDelivery}>
									<RequestButtonText>{ride.retorno ? 'Retornar Restaurante' : 'Finalizar'}</RequestButtonText>
								</RestaurantButton>
							</Fragment>
					</Fragment>
				)		
			} else if( ride.status === 'onBackWay') {
				return (
					<Fragment>
						<TypeTitle>Favor retorne ao restaurante com troco/maquineta</TypeTitle>
						<TypeDescription>Clique em finalizar somente após retornar ao restaurante</TypeDescription>
							<Fragment>
								<View style={{ flexDirection: 'row', justifyContent: 'space-around'}} />
								<RestaurantButton onPress={this.finishDelivery}>
									<RequestButtonText>{'Finalizar'}</RequestButtonText>
								</RestaurantButton>
							</Fragment>
					</Fragment>
				)		
			} else if( ride.status === 'finished') {
				return (
					<Fragment>
						<TypeTitle>Obrigado por essa viagem</TypeTitle>
						<TypeDescription>Confira abaixo o seu pagamento</TypeDescription>
						<View style={{ flex: 0.8, justifyContent: 'center', alignItems: 'center'}}>
							<TypeTitle>R$ {ride.tax - 0.12*ride.tax}</TypeTitle>
						</View>
							<Fragment>
								<View style={{ flexDirection: 'row', justifyContent: 'space-around'}} />
								<RestaurantButton onPress={this.dismiss}>
									<RequestButtonText>{'Entendido'}</RequestButtonText>
								</RestaurantButton>
							</Fragment>
					</Fragment>
				)		
			}
			// default:
			// return (
			// 	<Fragment>
			// 		<TypeTitle>Você tem uma entrega disponível</TypeTitle>
			// 		<TypeDescription>Clique abaixo para aceitar</TypeDescription>
			// 		{this.state.loading ? <Spinner /> : (
			// 			<Fragment>
			// 				<TouchableOpacity onPress={this.handleAcceptRide}>
			// 					<Thumbnail large source={require('../../assets/motoboy.png')} />
			// 				</TouchableOpacity>
			// 				<TypeTitle>{this.props.ride.name}</TypeTitle>
			// 				<TypeDescription>{this.props.rideDistance/1000} km</TypeDescription>
			
			// 				<RequestButton onPress={() => {}}>
			// 					<RequestButtonText>Recusar</RequestButtonText>
			// 				</RequestButton>
			// 			</Fragment>
			// 		)}
			// 	</Fragment>
			// )
	}

	openGoogleMaps = (lat , lng ) => {
		const { ride } = this.props
		const scheme = Platform.select({ ios: 'maps:0,0?q=', android: 'geo:0,0?q=' });
		const latLng = `${lat},${lng}`;
		console.log('latitude longitude maps', latLng)
		const label = 'Rotas para restaurante';
		const url = Platform.select({
			ios: `${scheme}${label}@${latLng}`,
			android: `${scheme}${latLng}(${label})`
		});
		Linking.openURL(url); 
	}

	refuseRide = async () => {
		this.setState({ loading: true })
		await firebase.database().ref(`register/commerce/motoboyPartner/${this.props.user.id}`).once('value', async snapshot => {
			let user = snapshot.val()
			await firebase.database().ref(`rides/${this.props.ride.id}`).update({
				refusedBy: [this.props.user.id]
			})
				.then(async () => {
					if(user.rideRefused){
						let rideRefused = _.filter(Object.values(user.rideRefused), e  => e.id === this.props.ride.id)
						console.log('ride refused', rideRefused)
						if(rideRefused.length === 0){
							await firebase.database().ref(`register/commerce/motoboyPartner/${this.props.user.id}`).update({
								rideRefused: [...Object.values(user.rideRefused), this.props.ride],
									onRide: false,
									activeRide: false,
							})
								.then(() => {
									this.props.setUser({
										...this.props.user,
										onRide: false,
										activeRide: false,
									})
									this.setState({ loading: false })
									return this.props.setRide(false)
								})
								.catch(error => {
									this.setState({ loading: false })
									console.log('error refusing ride', error)
								})
							} else {
								this.props.setUser({
									...this.props.user,
									onRide: false,
									activeRide: false,
								})
								this.setState({ loading: false })
								return this.props.setRide(false)
							}
						} else {
							await firebase.database().ref(`register/commerce/motoboyPartner/${this.props.user.id}`).update({
								rideRefused: [this.props.ride],
									onRide: false,
									activeRide: false,
							})
								.then(() => {
									this.props.setUser({
										...this.props.user,
										onRide: false,
										activeRide: false,
									})
									this.setState({ loading: false })
									return this.props.setRide(false)
								})
								.catch(error => {
									this.setState({ loading: false })
									console.log('error refusing ride', error)
								})
						}
				})
				.catch(error => {
					console.log('error updating ride with refused id', error)
				})
		})
	}

	onRestaurant = async () => {
		this.setState({ loading: true })
		await firebase.database().ref(`rides/${this.props.ride.id}`).update({
			status: 'onRestaurant'
		})
			.then(() => {
				this.props.setRide({
					...this.props.ride,
					status: 'onRestaurant'
				})
				this.setState({ loading: false})
			})
			.catch(error => {
				this.setState({ loading: false})
				console.log('error updating ride status', error)
			})
	}

	startDelivery = async () => {
		this.setState({ loading: true })
		await firebase.database().ref(`rides/${this.props.ride.id}`).update({
			status: 'onDelivery'
		})
			.then(() => {
				this.props.setRide({
					...this.props.ride,
					status: 'onDelivery'
				})
				this.setState({ loading: false})
			})
			.catch(error => {
				this.setState({ loading: false})
				console.log('error updating ride status', error)
			})
	}

	wayBack = async () => {
		this.setState({ loading: true })
		await firebase.database().ref(`rides/${this.props.ride.id}`).update({
			status: 'onBackWay'
		})
			.then(() => {
				this.props.setRide({
					...this.props.ride,
					status: 'onBackWay'
				})
				this.setState({ loading: false})
			})
			.catch(error => {
				this.setState({ loading: false})
				console.log('error updating ride status', error)
			})
	}

	finishDelivery = async () => {
		this.setState({ loading: true })
		await firebase.database().ref(`rides/${this.props.ride.id}`).update({
			status: 'finished'
		})
			.then(async () => {
				this.props.setRide({
					...this.props.ride,
					status: 'finished'
				})
				// .update({
				// 	earnings: this.props.user.earnings ? [ ...Object.values(this.props.user.earnings) , { date: today, tax: this.props.ride.tax }] : [{ date: today, tax: this.props.ride.tax }],
				// 	rides: this.props.user.rides ? [...Object.values(this.props.user.rides), this.props.ride] : [this.props.ride]
				// })
			})
			.catch(error => {
				this.setState({ loading: false})
				console.log('error updating ride status', error)
			})
	}

	dismiss = async () => {
		this.setState({ loading: true })
		await firebase.database().ref(`register/commerce/motoboyPartner/${this.props.user.id}`).once('value', async snap => {
			let motoboy = snap.val()
			console.log('motoboyyyyyy', motoboy, this.props.ride.tax, this.props.ride)
			let index;
			let earnings;
				if(this.props.user.earnings){
					index = _.findIndex(motoboy.earnings, e => e.date === today)
				}
				if(motoboy.earnings){
					index = _.findIndex(motoboy.earnings, e => e.date === today)
					if(index !== -1){
						motoboy.earnings[index] = { date: today, tax: [...motoboy.earnings[index].tax, this.props.ride.tax]}
					} else {
						motoboy.earnings[-1] = { date: today, tax: [this.props.ride.tax] } 
					}
				} else {
					earnings = [ { date: today, tax: [this.props.ride.tax]} ]
				}
				await firebase.database().ref(`register/commerce/motoboyPartner/${this.props.user.id}`).update({
					earnings: motoboy.earnings ? motoboy.earnings : earnings,
					rides: this.props.user.rides ? [...Object.values(this.props.user.rides), this.props.ride] : [this.props.ride],
					onRide: false,
					activeRide: false,
				})
					.then(() => {
						this.setState({ loading: false})
						console.log('successfully set earning and rite for motoboy')
						return this.props.setRide(false)
					})
					.catch(error => {
						this.setState({ loading: false})
						console.log('error set earning and rite for motoboy', error)
					})
		})
		// await firebase.database().ref(`register/commerce/motoboyPartner/${this.props.user.id}`).update({
		// 	onRide: false,
		// 	activeRide: false,
		// })
			// .then(() => {
			// 	this.setState({ loading: false })
			// 	return this.props.setRide(false)
			// })
			// .catch(error => {
			// 	this.setState({ loading: false })
			// 	console.log('error dimiss ride', error)
			// })
	}

	render(){
		const { ride } = this.props
		return (
			<Container>
				{this.handleRide(ride)}
			</Container>
    )
	}	
}

const mapStateToProps = state => ({
	user: state.user.user,
})

export default connect(mapStateToProps, { setRide, setUser })(Details)